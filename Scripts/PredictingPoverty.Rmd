---
title: "Problem Set 2 - BDML"
author: "Cristian Mu√±oz - Vivian Cabanzo - Zenneth Olivero - Laura Diaz"
date: "2025-09-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Predicting Poverty

# Predicci√≥n de Pobreza en Colombia

## 1. Introducci√≥n

## 2. Datos

### 2.1. Limpieza de datos

### - Paquetes y librerias

A continuaci√≥n se cargan los paquetes y librerias necesarias para el an√°lisis de informaci√≥n.

```{r}
# Instalar y cargar pacman (gestor de paquetes)
if (!require("pacman")) install.packages("pacman")
library(pacman)

# Cargar paquetes necesarios
pacman::p_load(
  knitr,         # Knit en RMarkdown
  tidyverse,     # Incluye dplyr, tidyr, ggplot2, readr, purrr
  readxl,        # Lectura de Excel
  janitor,       # Limpieza r√°pida
  skimr,         # Res√∫menes descriptivos
  styler,        # Estilo de c√≥digo
  corrplot,      # Matrices de correlaci√≥n
  boot,          # Bootstrap
  modelsummary,  # Res√∫menes en tablas
  scales,        # Para formatear ejes
  gt,            # Tablas elegantes
  broom,         # Modelos -> data.frames
  survey,        # Encuestas complejas
  rio,           # Importar/exportar
  stargazer,     # Estad√≠sticas descriptivas y modelos
  gtsummary,     # Tablas m√©dicas/sociales
  gridExtra,     # Organizar gr√°ficos
  labelled,      # Manejo de etiquetas
  tibble,        # Tablas en consola
  kableExtra,    # Mejorar tablas
  stringi,       # Convertir Car√°cteres
  webshot2,      # Guardar HTML y PDF
  caret,         # Herramientas preprocesamiento, selecci√≥n de modelos y evaluaci√≥n de algoritmos de ML
  glmnet,        # Implementaci√≥n eficiente de modelos de regresi√≥n regularizados (EN, Lasso y Ridge)
  MLeval,        # Funciones para evaluar modelos de clasificaci√≥n y regresi√≥n con m√©tricas y gr√°ficos
  MLmetrics,     # Colecci√≥n de m√©tricas de evaluaci√≥n para modelos de machine learning
  rpart,         # Implementar arboles de decision
  rpart.plot,    # Graficos de arboles
  Metrics,        # Evaluar modelos predictivos
  pROC
)

# Verificar paquetes cargados
pacman::p_loaded()

```

### - Cargar bases de datos

Se proceden a cargar las bases de datos definidas para el an√°lisis.

**Nota:** En primera instancia, se debe garantizar la reproducibilidad del script para cualquier usuario, por lo que se precisa la necesidad de que, tanto el arhivo R Markdown como las bases de datos se almacenen en la misma carpeta o ruta.

```{r}
# Lista de datasets que deben estar en la misma carpeta del .Rmd
Datasets <- c(
  "sample_submission.csv",
  "train_hogares.csv",
  "train_personas.csv",
  "test_hogares.csv",
  "test_personas.csv"
)

# Verificaci√≥n
for (Dataset in Datasets) {
  if (file.exists(Dataset)) {
    cat("El dataset", Dataset, "se encuentra en la carpeta para su respectivo cargue a R.\n")
  } else {
    cat("El dataset", Dataset, "NO se encuentra en la carpeta para su respectivo cargue a R.\n")
  }
}

```

Posteriormente, se proceden a cargar los datasets

```{r}
# Cargar datasets en R
sample_submission <- read.csv("sample_submission.csv", stringsAsFactors = FALSE)
train_hogares     <- read.csv("train_hogares.csv", stringsAsFactors = FALSE)
train_personas    <- read.csv("train_personas.csv", stringsAsFactors = FALSE)
test_hogares      <- read.csv("test_hogares.csv", stringsAsFactors = FALSE)
test_personas     <- read.csv("test_personas.csv", stringsAsFactors = FALSE)

# Confirmar cargue mostrando dimensiones de cada dataset
cat("sample_submission:", nrow(sample_submission), "filas y", ncol(sample_submission), "columnas.\n")
cat("train_hogares:", nrow(train_hogares), "filas y", ncol(train_hogares), "columnas.\n")
cat("train_personas:",nrow(train_personas), "filas y", ncol(train_personas), "columnas.\n")
cat("test_hogares:", nrow(test_hogares), "filas y", ncol(test_hogares), "columnas.\n")
cat("test_personas:", nrow(test_personas), "filas y", ncol(test_personas), "columnas.\n")

```

### - Exploraci√≥n de bases de datos

Se analizan la bases de datos de entrenamiento y de prueba correspondiente a hogares y a personas, es necesario tener en cuenta que el objetivo es predecir la pobreza a nivel de hogares, por lo que es posible crear variables relevantes para la predicci√≥n de pobreza desde el nivel de personas para robustecer los resultados.

Analisis de las bases de datos de entrenamiento y de prueba a nivel de hogares:

```{r}
# Comparar variables entre train y test Hogares
vars_comunes_hog <- intersect(names(train_hogares), names(test_hogares))
vars_train_hog <- setdiff(names(train_hogares), names(test_hogares))
vars_test_hog <- setdiff(names(test_hogares), names(train_hogares))

# Variables exclusivas en test
solo_test_hog <- if (length(vars_test_hog) == 0) "Ninguna variable" else paste(vars_test_hog, collapse = ", ")

# Construir tabla resumen
comp_bd_hogares <- tibble(
  Categoria = c("En ambos datasets", "Solo en train_hogares", "Solo en test_hogares"),
  Cantidad  = c(length(vars_comunes_hog), length(vars_train_hog), ifelse(length(vars_test_hog) == 0, 0, length(vars_test_hog))),
  Variables = c(
    paste(vars_comunes_hog, collapse = ", "),
    paste(vars_train_hog, collapse = ", "),
    solo_test_hog
  )
)

# Crear tabla gt
comp_bd_hogares <- comp_bd_hogares %>%
  gt() %>%
  tab_header(
    title = "Resumen de Variables entre la muestra de entrenamiento y de prueba en Hogares"
  ) %>%
  cols_label(
    Categoria = "Categor√≠a",
    Cantidad = "N¬∞ de Variables",
    Variables = "Variables"
  )

# Crear carpeta "Tablas y Graficos"
if (!dir.exists("Tablas y Graficos")) dir.create("Tablas y Graficos")

# Exportar en HTML, PDF y PNG dentro de "Tablas y Graficos"
gtsave(comp_bd_hogares, "Tablas y Graficos/1.Comparacion_bases_hogares.html")

webshot2::webshot(
  "Tablas y Graficos/1.Comparacion_bases_hogares.html",
  "Tablas y Graficos/1.Comparacion_bases_hogares.pdf"
)

gtsave(comp_bd_hogares, "Tablas y Graficos/1.Comparacion_bases_hogares.png")


# Mostrar en pantalla
comp_bd_hogares

```

La Tabla que precede presenta un resumen comparativo de las variables disponibles en la muestra de entrenamiento y de prueba a nivel de hogares, se observa que ambas bases comparten un total de 16 variables, entre ellas el identificador del hogar (id), atributo fundamental para la creacion de nuevas variables, as√≠ como variables socioecon√≥micas y demogr√°ficas.

Adicionalmente, se identifican 7 variables exclusivas de la base de entrenamiento (Ingtotug, Ingtotugarr, Ingpcug, Pobre, Indigente, Npobres, Nindigentes), las cuales no est√°n presentes en la base de prueba. Por su parte, el conjunto de prueba no presenta variables exclusivas, lo cual se se√±ala expl√≠citamente como "Ninguna variable".


A cotinuaci√≥n se presenta la comparaci√≥n de variables entre las muestras de entrenamiento y de prueba a nivel de hogares, se examinan de manera sistem√°tica aspectos como el tipo de dato para identificar la consistencia en el tipo de variables en ambas bases de datos.


```{r}
# Funci√≥n: obtener tipo de variable para un dataset
tipo_var_hogares <- function(df) {
  map_dfr(names(df), function(var) {
    tibble(
      Variable = var,
      Tipo = class(df[[var]])[1]
    )
  })
}

# Calcular tipos para train y test
var_train_hog <- tipo_var_hogares(train_hogares)
var_test_hog <- tipo_var_hogares(test_hogares)

# Unir en una sola tabla comparativa
comb_tipo_var_hog <- full_join(
  var_train_hog %>% rename_with(~paste0(., "_train"), -Variable),
  var_test_hog  %>% rename_with(~paste0(., "_test"), -Variable),
  by = "Variable"
)

# Reemplazar NA
comb_tipo_var_hog <- comb_tipo_var_hog %>%
  mutate(
    Tipo_train = ifelse(is.na(Tipo_train), "No existe variable en el dataset", Tipo_train),
    Tipo_test  = ifelse(is.na(Tipo_test),  "No existe variable en el dataset", Tipo_test)
  )

# Crear tabla con gt
comb_tipo_var_hog <- comb_tipo_var_hog %>%
  select(Variable, Tipo_train, Tipo_test) %>%
  gt() %>%
  tab_header(
    title = "Tipo de Variables: Muestra de entrenamiento y de prueba en Hogares"
  ) %>%
  tab_spanner(
    label = "Muestra de Entrenamiento",
    columns = c(Tipo_train)
  ) %>%
  tab_spanner(
    label = "Muestra de Prueba",
    columns = c(Tipo_test)
  ) %>%
  cols_label(
    Variable = "Variable",
    Tipo_train = "Tipo de variable",
    Tipo_test = "Tipo de variable"
  )

# Exportar dentro de la subcarpeta "Tablas y Graficos"
gtsave(comb_tipo_var_hog, "Tablas y Graficos/2.Comparacion_tipo_var_hogares.html")

webshot2::webshot(
  "Tablas y Graficos/2.Comparacion_tipo_var_hogares.html",
  "Tablas y Graficos/2.Comparacion_tipo_var_hogares.pdf"
)

gtsave(comb_tipo_var_hog, "Tablas y Graficos/2.Comparacion_tipo_var_hogares.png")

# Mostrar en pantalla
comb_tipo_var_hog

```

En conjunto, esta tabla complementa el an√°lisis previo y constituye una herramienta fundamental para orientar las decisiones de limpieza, imputaci√≥n y selecci√≥n de variables en la construcci√≥n del modelo de predicci√≥n de pobreza.

Por otra parte, es fundamental que las bases de datos de entrenamiento y de prueba utilicen el mismo conjunto de variables explicativas, esto se debe a que el modelo predictivo aprende una funci√≥n definida en un espacio de caracter√≠sticas espec√≠fico; si en la etapa de predicci√≥n se presentan variables distintas a las utilizadas en el entrenamiento, los modelos a plantear carecer√≠an de la informaci√≥n necesaria para generar resultados v√°lidos. 

De igual forma, la inclusi√≥n de variables adicionales en el entrenamiento que no est√°n presentes en la prueba impide evaluar correctamente la capacidad de predicci√≥n de modelos. Es importante resaltar que, la variable objetivo "Pobre" est√° disponible √∫nicamente en la base de entrenamiento y no en la base de prueba, ya que el prop√≥sito principal del analisis es generar predicciones de pobreza a partir de datos conocidos.

Teniendo en cuenta lo anterior, en primera instancia, se define a un hogar como pobre cuando el ingreso del hogar es inferior a la "Linea de Pobreza", como se define a continuaci√≥n:

$$
\
Pobre = I \cdot (Ingreso < \text{L√≠nea de Pobreza})
\
$$
Se asigna el valor de la variable "Pobre" de acuerdo con el resultado de la funci√≥n que precede, 

$$
\
Donde \ I:
\\
I(\text{Funci√≥n indicadora}) =
\begin{cases} 
0, & \text{Ingreso superior a la linea de pobreza = No Pobre} \\
1, & \text{Ingreso inferior a la linea de pobreza = Pobre}
\end{cases}
\
$$


De acuerdo con la definici√≥n anterior, se seleccionan en la base de datos de entrenamiento aquellas variables que se encuentran en la base de prueba y se mantiene la variable objetivo "Pobre", con la cual se entrenar√°n los diferentes modelos para realizar predicciones en la base de prueba.

```{r}
# Variables en com√∫n entre train y test hogares
vars_comunes_hog

# Mantener las variables comunes y "Pobre"
vars_comunes_hog <- c(vars_comunes_hog, "Pobre")

# Filtro de train_hogares
train_hogares2 <- train_hogares %>%
  select(all_of(vars_comunes_hog))

# Verificar
cat("N√∫mero de variables en train original:", ncol(train_hogares), "\n")
cat("N√∫mero de variables en train depurado:", ncol(train_hogares2), "\n")

```
Al realizar la depuraci√≥n inicial se exploran las variables restantes, con el objetivo de comprenderlas a fondo y definir su relevancia dentro de la prediccion de pobreza de los hogares.


```{r}
# Renombrar variables en train_hogares2
train_hogares2 <- train_hogares2 %>%
  rename(
    Total_habitaciones = P5000,
    Dormitorios = P5010,
    Tipo_vivienda = P5090,
    Cuota_amortizacion = P5100,
    Valor_estimado_arriendo = P5130,
    Valor_arriendo = P5140,
  )

# Renombrar variables en test_hogares igual que en train_hogares
test_hogares2 <- test_hogares %>%
  rename(
    Total_habitaciones = P5000,
    Dormitorios = P5010,
    Tipo_vivienda = P5090,
    Cuota_amortizacion = P5100,
    Valor_estimado_arriendo = P5130,
    Valor_arriendo = P5140,
  )

# Crear diccionario de variables
diccionario_vars <- tibble::tibble(
  Variable = names(train_hogares2),
  Descripcion = "Descripci√≥n pendiente"
)

# Si deseas agregar descripciones personalizadas a algunas variables conocidas:
diccionario_vars <- diccionario_vars %>%
  mutate(
    Descripcion = case_when(
      Variable == "id" ~ "Llave √∫nica del hogar",
      Variable == "Clase" ~ "1. Cabecera; 2. Resto (centros poblados y rural dispersa)",
      Variable == "Dominio" ~ "Dominio geogr√°fico: √°reas metropolitanas, cabeceras y resto",
      Variable == "Total_habitaciones" ~ "Total de habitaciones del hogar",
      Variable == "Dormitorios" ~ "N√∫mero de dormitorios",
      Variable == "Tipo_vivienda" ~ "Tipo de vivienda: a.Propia, totalmente pagada 
    b. Propia, la est√°n pagando
    c. En arriendo o subarriendo
    d. En usufructo e. Posesi√≥n sin titulo (ocupante)
    f. Otra",
      Variable == "Cuota_amortizacion" ~ "Valor de cuota de amortizaci√≥n de vivienda",
      Variable == "Valor_estimado_arriendo" ~ "Valor estimado del arriendo de la vivienda",
      Variable == "Valor_arriendo" ~ "Valor real de arriendo mensual",
      Variable == "Nper" ~ "N√∫mero de personas en el hogar",
      Variable == "Npersug" ~ "N√∫mero de personas en la unidad de gasto",
      Variable == "Li" ~ "L√≠nea de Indigencia",
      Variable == "Lp" ~ "L√≠nea de Pobreza",
      Variable == "Fex_c" ~ "Factor de Expansi√≥n",
      Variable == "Depto" ~ "Departamento de residencia",
      Variable == "Fex_dpto" ~ "Factor de Expansi√≥n departamental",
      Variable == "Pobre" ~ "1 = Pobre ; 0 = No pobre (solo en entrenamiento)",
      TRUE ~ Descripcion
    )
  )

# Crear tabla con gt
diccionario_vars <- diccionario_vars %>%
  gt() %>%
  tab_header(
    title = "Diccionario de Variables: train_hogares2"
  ) %>%
  cols_label(
    Variable = "Variable",
    Descripcion = "Descripci√≥n"
  )

# Exportar en los tres formatos dentro de la carpeta

# HTML
gtsave(diccionario_vars, "Tablas y Graficos/3.Diccionario_train_hogares2.html")

# PDF
webshot2::webshot(
  "Tablas y Graficos/3.Diccionario_train_hogares2.html",
  "Tablas y Graficos/3.Diccionario_train_hogares2.pdf"
)

# PNG
gtsave(diccionario_vars, "Tablas y Graficos/3.Diccionario_train_hogares2.png")

# Mostrar en pantalla
diccionario_vars

```


Es necesario resaltar que, si bien las variables que contiene ingresos en la base de entrenamiento fueron eliminadas, no presenta ninguna implicacion ya que, dentro de la base existe la variable "Pobre", la cual por definici√≥n representa que los ingresos de determinados hogares son inferiores a la linea de pobreza.

A contiuaci√≥n, se presentan las variables contenidas en el dataset de entrenamiento de Hogares y se exploran los valores faltantes.

```{r}
# Calcular % de faltantes en TRAIN hogares
faltantes_train_hog <- train_hogares2 %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Porcentaje_NA") %>%
  mutate(Base = "Entrenamiento")

# Calcular % de faltantes en TEST hogares
faltantes_test_hog <- test_hogares2 %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Porcentaje_NA") %>%
  mutate(Base = "Prueba")

# Unir ambas bases
faltantes_comp_hog <- bind_rows(faltantes_train_hog, faltantes_test_hog)

# Reordenar factores id, Clase, Dominio y Depto 
orden_vars <- c(setdiff(unique(faltantes_comp_hog$Variable), 
                        c("Depto", "Dominio","Clase", "id")),
                      "Depto", "Dominio","Clase", "id")

faltantes_comp_hog <- faltantes_comp_hog %>%
  mutate(Variable = factor(Variable, levels = orden_vars))

# Gr√°fico comparativo
grafico_faltantes <- ggplot(faltantes_comp_hog, aes(x = Variable, 
                                                y = Porcentaje_NA, fill = Base)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = paste0(round(Porcentaje_NA, 2), "%")), 
            position = position_dodge(width = 0.9), 
            vjust = -0.3, size = 3) +
  coord_flip() +
  labs(title = "Comparaci√≥n de % de valores faltantes por variable\nTrain vs Test (hogares)",
       x = "Variable", y = "% de valores faltantes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(values = c("Entrenamiento" = "lightyellow4",
                               "Prueba"        = "#FFFF00")) 

# Exportar gr√°fico a PDF
ggsave(
  filename = "Tablas y Graficos/4.Faltantes_Train_Hogares.pdf",
  plot = grafico_faltantes,
  width = 10, height = 6
)

# Exportar gr√°fico a PNG
ggsave(
  filename = "Tablas y Graficos/4.Faltantes_Train_Hogares.png",
  plot = grafico_faltantes,
  width = 10, height = 6,
  dpi = 300
)

# Mostrar en pantalla
print(grafico_faltantes)

```


La gr√°fica que precede, ofrece una visi√≥n m√°s precisa de la calidad de los datos, resaltando aquellas variables con un porcentaje considerable de valores faltantes que podr√≠an comprometer el desempe√±o de los modelos predictivos. Se evidencia un alto porcentaje de datos faltantes en las mismas variables para las dos bases, a saber, el valor estimado en caso de pagar arriendo en una vivienda, la cuota de amortizaci√≥n por cr√©dito hipotecario y el valor actual del arriendo, por lo que dichas variables podrian omitirse en ambas bases.

Adicionalmente, las dem√°s variables no presentan datos faltantes, sin embargo, "id", "Clase", "Dominio" y "Depto" son atributos de identificacion por lo que no se usar√°n como posibles predictoras aunque se mantengan en la base.

Por su parte, los factores de expansi√≥n no representan caracteristicas intrinsecas que contribuyan a la predicci√≥n del estado de pobreza de un hogar en Colombia, estas corresponden a atributos para el analisis poblacional por lo que no se utilizar√°n para predecir.

En cuanto a la linea de pobreza y a la linea de indigencia, estas variables no son necesarias puesto que ya existe la variable que clasifica a los hogares pobres de aquellos que no lo son.

Por lo anterior, dentro de lo explorado se mantendr√°n las variables "Tipo de vivienda" y "Numero de personas en el hogar", en este orden de ideas se debe proceder a explorar las bases de entrenamiento y de prueba en el nivel de Personas para identificar posibles variables que contribuyan a la prediccion adecuada del estado de pobreza.


```{r}
# Comparar variables entre train y test Personas
vars_comunes_pers <- intersect(names(train_personas), names(test_personas))
vars_train_pers <- setdiff(names(train_personas), names(test_personas))
vars_test_pers <- setdiff(names(test_personas), names(train_personas))

# Variables exclusivas en test
solo_test_pers <- if (length(vars_test_pers) == 0) "Ninguna variable" else paste(vars_test_pers, collapse = ", ")

# Construir tabla resumen
comp_bd_personas <- tibble(
  Categoria = c("En ambos datasets", "Solo en train_personas", "Solo en test_personas"),
  Cantidad  = c(length(vars_comunes_pers), length(vars_train_pers), ifelse(length(vars_test_pers) == 0, 0, length(vars_test_pers))),
  Variables = c(
    paste(vars_comunes_pers, collapse = ", "),
    paste(vars_train_pers, collapse = ", "),
    solo_test_pers
  )
)

# Crear tabla gt
comp_bd_personas <- comp_bd_personas %>%
  gt() %>%
  tab_header(
    title = "Resumen de Variables entre la muestra de entrenamiento y de prueba en Hogares"
  ) %>%
  cols_label(
    Categoria = "Categor√≠a",
    Cantidad = "N¬∞ de Variables",
    Variables = "Variables"
  )

# Crear carpeta "Tablas y Graficos"
if (!dir.exists("Tablas y Graficos")) dir.create("Tablas y Graficos")

# Exportar en HTML, PDF y PNG dentro de "Tablas y Graficos"
gtsave(comp_bd_personas, "Tablas y Graficos/5.Comparacion_bases_personas.html")

webshot2::webshot(
  "Tablas y Graficos/5.Comparacion_bases_personas.html",
  "Tablas y Graficos/5.Comparacion_bases_personas.pdf"
)

gtsave(comp_bd_personas, "Tablas y Graficos/5.Comparacion_bases_personas.png")

# Mostrar en pantalla
comp_bd_personas

```
Del analisis de las variables en com√∫n en las bases de Personas, se identifican 63 que se encuentran en la base de entrenamiento y de prueba, se proceder√° a realizar un analisis de valores faltantes para seleccionar de forma adecuada variables que permitan predecir el estado de pobreza.



```{r}
# Calcular % de faltantes en TRAIN_PERSONAS y TEST_PERSONAS
faltantes_train_pers <- train_personas %>%
  select(all_of(vars_comunes_pers)) %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Porcentaje_NA") %>%
  mutate(Base = "Train Personas")

faltantes_test_pers <- test_personas %>%
  select(all_of(vars_comunes_pers)) %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Porcentaje_NA") %>%
  mutate(Base = "Test Personas")

# Unir y clasificar en rangos de % de faltantes
faltantes_comp_pers <- bind_rows(faltantes_train_pers, faltantes_test_pers) %>%
  mutate(
    Categoria = case_when(
      Porcentaje_NA == 0 ~ "0%",
      Porcentaje_NA > 0 & Porcentaje_NA <= 30 ~ "1% - 30%",
      Porcentaje_NA > 30 & Porcentaje_NA <= 50 ~ "31% - 50%",
      Porcentaje_NA > 50 & Porcentaje_NA < 100 ~ "51% - 99%",
      Porcentaje_NA == 100 ~ "100%"
    )
  ) %>%
  group_by(Base, Categoria) %>%
  summarise(N_variables = n(), .groups = "drop")

# Crear gr√°fico resumido
porc_faltantes_pers <- ggplot(faltantes_comp_pers, aes(x = Categoria, y = N_variables, fill = Base)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(
    aes(label = N_variables),
    position = position_dodge(width = 0.9),
    vjust = -0.3, size = 4
  ) +
  labs(
    title = "Distribuci√≥n de variables comunes seg√∫n % de faltantes\nMuestra de entrenamiento y prueba de Personas",
    x = "Categor√≠a de % de faltantes", y = "N√∫mero de variables"
  ) +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
  scale_fill_manual(
    values = c("Train Personas" = "lightyellow4",  # verde oliva oscuro
               "Test Personas"  = "#FFD700")  # amarillo dorado
  )


# Exportar gr√°fico en PDF y PNG dentro de "Tablas y Graficos"
# PDF
ggsave(
  filename = "Tablas y Graficos/6.Resumen_Faltantes_Train_vs_Test_Personas.pdf",
  plot = porc_faltantes_pers,
  width = 8, height = 6
)

# PNG
ggsave(
  filename = "Tablas y Graficos/6.Resumen_Faltantes_Train_vs_Test_Personas.png",
  plot = porc_faltantes_pers,
  width = 8, height = 6,
  dpi = 300
)

# Mostrar en consola
print(porc_faltantes_pers)

```

De acuerdo con la grafica, existen 45 variables con mas del 50% de valores faltantes en las dos bases a nivel de personas, por lo que no es procedente tenerlas en cuenta para el entrenamiento. Por su parte, 18 variables se revisar√°n a continuaci√≥n:



```{r}
# Crear tabla detallada de % de faltantes
# Unir porcentajes de faltantes de train y test lado a lado
faltantes_detalle_pers <- left_join(
  faltantes_train_pers %>% rename(Pct_Faltantes_Train = Porcentaje_NA),
  faltantes_test_pers  %>% rename(Pct_Faltantes_Test = Porcentaje_NA),
  by = "Variable"
)

# Clasificar categor√≠as
faltantes_detalle_pers <- faltantes_detalle_pers %>%
  mutate(
    Categoria = case_when(
      Pct_Faltantes_Train == 0 & Pct_Faltantes_Test == 0 ~ "0% faltantes",
      (Pct_Faltantes_Train >= 1 & Pct_Faltantes_Train <= 30) |
        (Pct_Faltantes_Test >= 1 & Pct_Faltantes_Test <= 30) ~ "1% - 30%",
      TRUE ~ "M√°s del 30%"
    )
  )

# Filtrar solo variables con 0%-30% faltantes
faltantes_interes_pers <- faltantes_detalle_pers %>%
  filter(Categoria %in% c("0% faltantes", "1% - 30%")) %>%
  select(Variable, Pct_Faltantes_Train, Pct_Faltantes_Test)

# Crear tabla con gt
tabla_faltantes_pers <- faltantes_interes_pers %>%
  gt() %>%
  tab_header(
    title = "Variables con valores faltantes (0%-30%)\nTrain Personas vs Test Personas"
  ) %>%
  cols_label(
    Variable = "Variable",
    Pct_Faltantes_Train = "% Faltantes Train",
    Pct_Faltantes_Test = "% Faltantes Test"
  ) %>%
  fmt_number(
    columns = c(Pct_Faltantes_Train, Pct_Faltantes_Test),
    decimals = 2
  ) %>%
  tab_options(
    table.font.size = 12,
    heading.align = "center"
  )

# Exportar tabla en HTML, PDF y PNG dentro de "Tablas y Graficos"
# HTML
gtsave(tabla_faltantes_pers, "Tablas y Graficos/7.Faltantes_Train_vs_Test_0a30.html")

# PDF
webshot2::webshot(
  "Tablas y Graficos/7.Faltantes_Train_vs_Test_0a30.html",
  "Tablas y Graficos/7.Faltantes_Train_vs_Test_0a30.pdf"
)

# PNG
gtsave(tabla_faltantes_pers, "Tablas y Graficos/7.Faltantes_Train_vs_Test_0a30.png")

# Mostrar en consola
tabla_faltantes_pers

```
```{r}
# Renombrar variables en ambos datasets (train y test)
renombrar_personas <- function(df) {
  df %>%
    rename(
      Parentesco_jefe = P6050,
      Edad = P6040,
      Sexo = P6020,
      Nivel_educativo = P6210,
      Actividad_Ocup = P6240
    )
}

train_personas2 <- renombrar_personas(train_personas)
test_personas2  <- renombrar_personas(test_personas)

# Variables comunes entre ambos datasets
vars_comunes_pers <- intersect(names(train_personas2), names(test_personas2))

# Calcular % de faltantes para TRAIN y TEST
calc_faltantes <- function(df, nombre_base) {
  df %>%
    select(all_of(vars_comunes_pers)) %>%
    summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
    pivot_longer(cols = everything(), names_to = "Variable", values_to = "Porcentaje_NA") %>%
    mutate(Base = nombre_base)
}

faltantes_train_pers <- calc_faltantes(train_personas2, "Train Personas")
faltantes_test_pers  <- calc_faltantes(test_personas2,  "Test Personas")

# Unir faltantes y clasificar categor√≠as
faltantes_comp_pers <- left_join(
  faltantes_train_pers %>% rename(Pct_Faltantes_Train = Porcentaje_NA),
  faltantes_test_pers  %>% rename(Pct_Faltantes_Test = Porcentaje_NA),
  by = "Variable"
) %>%
  mutate(
    Categoria = case_when(
      Pct_Faltantes_Train == 0 & Pct_Faltantes_Test == 0 ~ "0% faltantes",
      (Pct_Faltantes_Train >= 1 & Pct_Faltantes_Train <= 30) |
        (Pct_Faltantes_Test >= 1 & Pct_Faltantes_Test <= 30) ~ "1% - 30%",
      TRUE ~ "M√°s del 30%"
    )
  )

# Preparar datos para el gr√°fico
faltantes_plot_pers <- faltantes_comp_pers %>%
  filter(Categoria %in% c("0% faltantes", "1% - 30%")) %>%
  select(Variable, Pct_Faltantes_Train, Pct_Faltantes_Test) %>%
  pivot_longer(
    cols = starts_with("Pct_Faltantes"),
    names_to = "Base",
    values_to = "Porcentaje_NA"
  ) %>%
  mutate(
    Base = ifelse(Base == "Pct_Faltantes_Train", "Train Personas", "Test Personas")
  )

# Crear gr√°fico comparativo
grafico_faltantes_pers <- ggplot(
  faltantes_plot_pers,
  aes(x = reorder(Variable, -Porcentaje_NA), y = Porcentaje_NA, fill = Base)
) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(
    aes(label = paste0(round(Porcentaje_NA, 1), "%")),
    position = position_dodge(width = 0.9),
    vjust = -0.25,
    size = 3
  ) +
  coord_flip() +
  labs(
    title = "Comparaci√≥n de % de valores faltantes (0%-30%)\nTrain Personas vs Test Personas",
    x = "Variable",
    y = "% de valores faltantes"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.y = element_text(size = 9)
  ) +
  scale_fill_manual(
    values = c("Train Personas" = "lightyellow4", "Test Personas" = "#FFFF00")
  )

# Exportar gr√°fico a PDF y PNG dentro de la carpeta
# PDF
ggsave(
  filename = "Tablas y Graficos/8.Grafico_Faltantes_Train_vs_Test_Personas.pdf",
  plot = grafico_faltantes_pers,
  width = 10,
  height = 6
)

# PNG
ggsave(
  filename = "Tablas y Graficos/8.Grafico_Faltantes_Train_vs_Test_Personas.png",
  plot = grafico_faltantes_pers,
  width = 10,
  height = 6,
  dpi = 300
)

# Mostrar gr√°fico en consola
print(grafico_faltantes_pers)

```
### - Base de Entrenamiento Final

La base de datos de entrenamiento definitiva para las predicciones de pobreza a nivel de hogares es:
train_hogares_final

```{r}
# Seleccionar variables de hogares
train_hogares_sel <- train_hogares2 %>%
  select(id, Clase, Dominio, Tipo_vivienda, Nper, Depto, Pobre)

# Filtrar jefe de hogar en personas
jefes_hogar <- train_personas2 %>%
  filter(as.character(Parentesco_jefe) == "1") %>%  #Asegura tomar "1" en cualquier tipo
  select(id, Parentesco_jefe, Sexo, Edad, Nivel_educativo, Actividad_Ocup)

# Merge hogares + jefe de hogar
train_hogares_final <- train_hogares_sel %>%
  left_join(jefes_hogar, by = "id")

# Reescalar variable Clase en train_hogares_final
train_hogares_final <- train_hogares_final %>%
  mutate(
    Clase = as.numeric(as.character(Clase)),  # asegurar tipo num√©rico
    Clase = case_when(
      Clase %in% c(1, 2) ~ Clase,
      TRUE ~ NA_real_
    ),
    Clase = factor(
      Clase,
      levels = c(1, 2),
      labels = c(
        "Cabecera",
        "Resto (centros poblados y rural dispersa)"
      )
    )
  )

# Reescalar variable Nivel_educativo
train_hogares_final <- train_hogares_final %>%
  mutate(
    Nivel_educativo = case_when(
      Nivel_educativo == 9 ~ NA_real_,
      Nivel_educativo == 1 ~ 1,
      Nivel_educativo == 2 ~ 2,
      Nivel_educativo %in% c(3, 4, 5) ~ 3,
      Nivel_educativo == 6 ~ 4,
      TRUE ~ NA_real_
    ),
    Nivel_educativo = factor(
      Nivel_educativo,
      levels = c(1, 2, 3, 4),
      labels = c(
        "Ninguno",
        "Preescolar",
        "M√°ximo bachiller",
        "Superior o universitaria"
      ),
      ordered = TRUE
    )
  )

# Reescalar Parentesco_jefe
train_hogares_final <- train_hogares_final %>%
  mutate(
    Parentesco_jefe = case_when(
      Parentesco_jefe == 1 ~ 1,      # jefe
      TRUE ~ 2                       # todos los dem√°s
    ),
    Parentesco_jefe = factor(
      Parentesco_jefe,
      levels = c(1, 2),
      labels = c("Jefe", "No jefe")
    )
  )

# Reescalar variable Sexo
train_hogares_final <- train_hogares_final %>%
  mutate(
    Sexo = case_when(
      Sexo %in% c(1, 2) ~ Sexo,   # valores v√°lidos
      TRUE ~ NA_real_             # cualquier otro c√≥digo ‚Üí NA
    ),
    Sexo = factor(
      Sexo,
      levels = c(1, 2),
      labels = c("Hombre", "Mujer")
    )
  )


# Reescalar Actividad_ocup
train_hogares_final <- train_hogares_final %>%
  mutate(
    # Asegurar que sea num√©rica antes de recodificar
    Actividad_Ocup = as.numeric(as.character(Actividad_Ocup)),

    # Mantener solo valores v√°lidos (1 a 6), los dem√°s -> NA
    Actividad_Ocup = case_when(
      Actividad_Ocup %in% 1:6 ~ Actividad_Ocup,
      TRUE ~ NA_real_
    ),

    # Convertir a factor con etiquetas descriptivas
    Actividad_Ocup = factor(
      Actividad_Ocup,
      levels = c(1, 2, 3, 4, 5, 6),
      labels = c(
        "Trabajando",
        "Buscando trabajo",
        "Estudiando",
        "Oficios del hogar",
        "Incapacitado permanente",
        "Otra actividad"
      ),
      ordered = FALSE
    )
  )

# Reescalar variable Tipo_vivienda en train_hogares_final
train_hogares_final <- train_hogares_final %>%
  mutate(
    Tipo_vivienda = as.numeric(as.character(Tipo_vivienda)),  # asegurar tipo num√©rico
    Tipo_vivienda = case_when(
      Tipo_vivienda %in% 1:6 ~ Tipo_vivienda,  # mantener v√°lidos
      TRUE ~ NA_real_
    ),
    # Re-codificar niveles uniendo las dos categor√≠as de "Propia"
    Tipo_vivienda = case_when(
      Tipo_vivienda %in% c(1, 2) ~ 1,  # Propia pagada o pagando
      Tipo_vivienda == 3 ~ 2,          # Arriendo o subarriendo
      Tipo_vivienda == 4 ~ 3,          # Usufructo
      Tipo_vivienda == 5 ~ 4,          # Ocupante sin t√≠tulo
      Tipo_vivienda == 6 ~ 5,          # Otra
      TRUE ~ NA_real_
    ),
    Tipo_vivienda = factor(
      Tipo_vivienda,
      levels = c(1, 2, 3, 4, 5),
      labels = c(
        "Propia (pagada o pagando)",
        "Arriendo o subarriendo",
        "Usufructo",
        "Ocupante sin t√≠tulo",
        "Otra"
      ),
      ordered = TRUE
    )
  )


# Convertir Pobre
train_hogares_final$Pobre <- factor(train_hogares_final$Pobre,
                                    levels = c(0, 1),
                                    labels = c("NoPobre", "Pobre"))                                    
# Asegurar formato de variables categ√≥ricas
train_hogares_final <- train_hogares_final %>%
  mutate(
    across(c(Clase, Dominio, Tipo_vivienda, Parentesco_jefe, Sexo,
             Nivel_educativo, Actividad_Ocup), as.factor)
  )

# Revisar resultado
head(train_hogares_final)
```

Revision de datos faltantes en train hogares:
```{r}
# Calcular n√∫mero y porcentaje de faltantes
faltantes_train_final <- train_hogares_final %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(
    cols = everything(),
    names_to = "Variable",
    values_to = "N_faltantes"
  ) %>%
  mutate(
    Pct_faltantes = round((N_faltantes / nrow(train_hogares_final)) * 100, 2)
  )

# Crear tabla con gt
tabla_faltantes_final <- faltantes_train_final %>%
  gt() %>%
  tab_header(title = "Valores faltantes en train_hogares_final") %>%
  cols_label(
    Variable = "Variable",
    N_faltantes = "N¬∞ Faltantes",
    Pct_faltantes = "% Faltantes"
  ) %>%
  fmt_number(
    columns = Pct_faltantes,
    decimals = 2
  )

# Exportar tabla en HTML, PDF y PNG

# HTML temporal
gtsave(tabla_faltantes_final, "Tablas y Graficos/9.Faltantes_train_hogares_final.html")

# PDF
webshot2::webshot(
  "Tablas y Graficos/9.Faltantes_train_hogares_final.html",
  "Tablas y Graficos/9.Faltantes_train_hogares_final.pdf"
)

# PNG
gtsave(tabla_faltantes_final, "Tablas y Graficos/9.Faltantes_train_hogares_final.png")

# Mostrar en consola
tabla_faltantes_final

```

### - Base de Prueba Final

La base de datos de prueba definitiva para las predicciones de pobreza a nivel de Hogares es:
test_hogares_final

```{r}
# Seleccionar variables de hogares
test_hogares_sel <- test_hogares2 %>%
  select(id, Clase, Dominio, Tipo_vivienda, Nper, Depto)

# Filtrar jefe de hogar en personas (num√©rico, factor o car√°cter)
jefes_hogar1 <- test_personas2 %>%
  filter(as.character(Parentesco_jefe) == "1") %>%  # se asegura de tomar "1" en cualquier tipo
  select(id, Parentesco_jefe, Sexo, Edad, Nivel_educativo, Actividad_Ocup)

# Merge hogares + jefe de hogar
test_hogares_final <- test_hogares_sel %>%
  left_join(jefes_hogar1, by = "id")


#Reescalar Clase de centro poblado
test_hogares_final <- test_hogares_final %>%
  mutate(
    Clase = as.numeric(as.character(Clase)),
    Clase = case_when(
      Clase %in% c(1, 2) ~ Clase,
      TRUE ~ NA_real_
    ),
    Clase = factor(
      Clase,
      levels = c(1, 2),
      labels = c(
        "Cabecera",
        "Resto (centros poblados y rural dispersa)"
      )
    )
  )


# Reescalar variable Nivel_educativo
test_hogares_final <- test_hogares_final %>%
  mutate(
    Nivel_educativo = case_when(
      Nivel_educativo == 9 ~ NA_real_,
      Nivel_educativo == 1 ~ 1,
      Nivel_educativo == 2 ~ 2,
      Nivel_educativo %in% c(3, 4, 5) ~ 3,
      Nivel_educativo == 6 ~ 4,
      TRUE ~ NA_real_
    ),
    Nivel_educativo = factor(
      Nivel_educativo,
      levels = c(1, 2, 3, 4),
      labels = c(
        "Ninguno",
        "Preescolar",
        "M√°ximo bachiller",
        "Superior o universitaria"
      ),
      ordered = TRUE
    )
  )

# Reescalar Parentesco_jefe
test_hogares_final <- test_hogares_final %>%
  mutate(
    Parentesco_jefe = case_when(
      Parentesco_jefe == 1 ~ 1,      # jefe
      TRUE ~ 2                       # todos los dem√°s
    ),
    Parentesco_jefe = factor(
      Parentesco_jefe,
      levels = c(1, 2),
      labels = c("Jefe", "No jefe")
    )
  )

# Reescalar variable Sexo
test_hogares_final <- test_hogares_final %>%
  mutate(
    Sexo = case_when(
      Sexo %in% c(1, 2) ~ Sexo,   # valores v√°lidos
      TRUE ~ NA_real_             # cualquier otro c√≥digo ‚Üí NA
    ),
    Sexo = factor(
      Sexo,
      levels = c(1, 2),
      labels = c("Hombre", "Mujer")
    )
  )

#Reescalar Activdad_Ocup
test_hogares_final <- test_hogares_final %>%
  mutate(
    # Asegurar que sea num√©rica antes de recodificar
    Actividad_Ocup = as.numeric(as.character(Actividad_Ocup)),

    # Mantener solo valores v√°lidos (1 a 6), los dem√°s -> NA
    Actividad_Ocup = case_when(
      Actividad_Ocup %in% 1:6 ~ Actividad_Ocup,
      TRUE ~ NA_real_
    ),

    # Convertir a factor con etiquetas descriptivas
    Actividad_Ocup = factor(
      Actividad_Ocup,
      levels = c(1, 2, 3, 4, 5, 6),
      labels = c(
        "Trabajando",
        "Buscando trabajo",
        "Estudiando",
        "Oficios del hogar",
        "Incapacitado permanente",
        "Otra actividad"
      ),
      ordered = FALSE
    )
  )

# Reescalar variable Tipo_vivienda en test_hogares_final
test_hogares_final <- test_hogares_final %>%
  mutate(
    Tipo_vivienda = as.numeric(as.character(Tipo_vivienda)),  # asegurar tipo num√©rico
    Tipo_vivienda = case_when(
      Tipo_vivienda %in% 1:6 ~ Tipo_vivienda,  # mantener v√°lidos
      TRUE ~ NA_real_
    ),
    # Re-codificar niveles uniendo las dos categor√≠as de "Propia"
    Tipo_vivienda = case_when(
      Tipo_vivienda %in% c(1, 2) ~ 1,  # Propia pagada o pagando
      Tipo_vivienda == 3 ~ 2,          # Arriendo o subarriendo
      Tipo_vivienda == 4 ~ 3,          # Usufructo
      Tipo_vivienda == 5 ~ 4,          # Ocupante sin t√≠tulo
      Tipo_vivienda == 6 ~ 5,          # Otra
      TRUE ~ NA_real_
    ),
    Tipo_vivienda = factor(
      Tipo_vivienda,
      levels = c(1, 2, 3, 4, 5),
      labels = c(
        "Propia (pagada o pagando)",
        "Arriendo o subarriendo",
        "Usufructo",
        "Ocupante sin t√≠tulo",
        "Otra"
      ),
      ordered = TRUE
    )
  )

# Asegurar formato de variables categ√≥ricas
test_hogares_final <- test_hogares_final %>%
  mutate(
    across(c(Clase, Dominio, Tipo_vivienda, Parentesco_jefe, Sexo,
             Nivel_educativo, Actividad_Ocup), as.factor)
  )

# Revisar resultado
head(test_hogares_final)
```

Revision de datos faltantes test hogares:

```{r}
# Calcular n√∫mero y porcentaje de faltantes
faltantes_test_final <- test_hogares_final %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(
    cols = everything(),
    names_to = "Variable",
    values_to = "N_faltantes"
  ) %>%
  mutate(
    Pct_faltantes = round((N_faltantes / nrow(test_hogares_final)) * 100, 2)
  )

# Crear tabla con gt
tabla_faltantes_test_final <- faltantes_test_final %>%
  gt() %>%
  tab_header(title = "Valores faltantes en test_hogares_final") %>%
  cols_label(
    Variable = "Variable",
    N_faltantes = "N¬∞ Faltantes",
    Pct_faltantes = "% Faltantes"
  ) %>%
  fmt_number(
    columns = Pct_faltantes,
    decimals = 2
  )

# Exportar tabla en HTML, PDF y PNG

# HTML temporal (necesario para generar PDF)
gtsave(tabla_faltantes_test_final, "Tablas y Graficos/10.Faltantes_test_hogares_final.html")

# PDF
webshot2::webshot(
  "Tablas y Graficos/10.Faltantes_test_hogares_final.html",
  "Tablas y Graficos/10.Faltantes_test_hogares_final.pdf"
)

# PNG
gtsave(tabla_faltantes_test_final, "Tablas y Graficos/10.Faltantes_test_hogares_final.png")

# Mostrar en pantalla
tabla_faltantes_test_final

```

Se evidencia un valor faltante en la variable Actividad_Ocup para cada base final, por lo que se procede a imputar con la moda:

```{r}
# Funci√≥n robusta: imputar por moda con impresi√≥n clara por base
imputar_moda <- function(df, variable, nombre_base = "Desconocida") {
  var <- df[[variable]]
  
  # Calcular NA antes
  n_na_antes <- sum(is.na(var))
  
  # Calcular la moda (valor m√°s frecuente, excluyendo NA)
  moda <- names(sort(table(var), decreasing = TRUE))[1]
  
  cat("Base:", nombre_base, "\n")
  cat("Variable:", variable, "\n")
  cat(" - NAs antes de imputar:", n_na_antes, "\n")
  cat(" - Moda usada:", moda, "\n")
  
  # Copiar el data frame (para seguridad)
  df2 <- df
  
  # Imputar manteniendo la clase
  if (is.factor(var)) {
    niveles <- levels(var)
    ordenado <- is.ordered(var)
    
    var_char <- as.character(var)
    var_char[is.na(var_char)] <- moda
    
    df2[[variable]] <- factor(var_char, levels = niveles, ordered = ordenado)
  } else {
    var_temp <- var
    var_temp[is.na(var_temp)] <- moda
    df2[[variable]] <- var_temp
  }
  
  # Calcular NA despu√©s
  n_na_despues <- sum(is.na(df2[[variable]]))
  
  cat(" - NAs despu√©s de imputar:", n_na_despues, "\n")
  cat("------------------------------------------------------------\n\n")
  
  return(df2)
}

# Aplicar imputaci√≥n a TRAIN y TEST con identificaci√≥n clara

train_hogares_final <- train_hogares_final %>%
  imputar_moda("Actividad_Ocup", nombre_base = "TRAIN Hogares Final") %>%
  imputar_moda("Nivel_educativo", nombre_base = "TRAIN Hogares Final")

test_hogares_final <- test_hogares_final %>%
  imputar_moda("Actividad_Ocup", nombre_base = "TEST Hogares Final") %>%
  imputar_moda("Nivel_educativo", nombre_base = "TEST Hogares Final")

# Resumen final
cat("\n RESUMEN FINAL DE NAs:\n")
cat("TRAIN - Actividad_Ocup:", sum(is.na(train_hogares_final$Actividad_Ocup)), "\n")
cat("TRAIN - Nivel_educativo:", sum(is.na(train_hogares_final$Nivel_educativo)), "\n")
cat("TEST  - Actividad_Ocup:", sum(is.na(test_hogares_final$Actividad_Ocup)), "\n")
cat("TEST  - Nivel_educativo:", sum(is.na(test_hogares_final$Nivel_educativo)), "\n")

```
```{r}
# Crear diccionario autom√°tico desde el dataset
dicc_final <- tibble(
  Variable = names(train_hogares_final),
  Descripcion = "Descripci√≥n pendiente"
) %>%
  mutate(
    Descripcion = case_when(
      Variable == "id" ~ "Llave √∫nica del hogar",
      Variable == "Clase" ~ "Clase de centro poblado: 1. Cabecera; 2. Resto (centros poblados y rural dispersa)",
      Variable == "Dominio" ~ "Dominio geogr√°fico: √°reas metropolitanas, cabeceras y resto",
      Variable == "Tipo_vivienda" ~ "Tipo de vivienda: a. Propia (Pagada o Pagando), b. Arriendo/subarriendo, c. Usufructo, d. Ocupante sin t√≠tulo, e. Otra",
      Variable == "Nper" ~ "N√∫mero de personas en el hogar",
      Variable == "Depto" ~ "Departamento de residencia",
      Variable == "Pobre" ~ "1 = Pobre ; 0 = No pobre (solo en base de entrenamiento)",
      Variable == "Parentesco_jefe" ~ "Parentesco con el jefe de hogar (1 = jefe, otros = distintos roles)",
      Variable == "Sexo" ~ "Sexo del jefe de hogar (1 = Hombre, 2 = Mujer)",
      Variable == "Edad" ~ "Edad del jefe de hogar (en a√±os)",
      Variable == "Nivel_educativo" ~ "Nivel educativo alcanzado por el jefe de hogar:\n a. Ninguno, b. Preescolar, c.M√°ximo Bachiller , d. Superior o universitaria",
      Variable == "Actividad_Ocup" ~ "Condici√≥n de actividad u ocupaci√≥n del jefe de hogar:\n a. Trabajando, b. Buscando trabajo, c. Estudiando, d. Oficios del hogar, e. Incapacitado permanente, f. Otra actividad",
      TRUE ~ Descripcion
    )
  )

# Crear tabla gt
dicc_final <- dicc_final %>%
  gt() %>%
  tab_header(
    title = "Diccionario de Variables en base de entrenamiento y de prueba"
  ) %>%
  cols_label(
    Variable = "Variable",
    Descripcion = "Descripci√≥n"
  )


# Exportar tabla en HTML, PDF y PNG
# HTML
gtsave(dicc_final, "Tablas y Graficos/10.Diccionario_train_hogares_final.html")

# PDF
webshot2::webshot(
  "Tablas y Graficos/10.Diccionario_train_hogares_final.html",
  "Tablas y Graficos/10.Diccionario_train_hogares_final.pdf"
)

# PNG
gtsave(dicc_final, "Tablas y Graficos/10.Diccionario_train_hogares_final.png")

# Mostrar en consola
dicc_final

```

### 2.2. Estad√≠sticas descriptivas
Tabla de estadisticas descriptivas para las dos bases de hogares:
   
```{r}
# Funci√≥n para obtener estad√≠sticas descriptivas
obtener_estadisticas <- function(df, nombre_base) {
  
  # Excluir variables no relevantes
  datos <- df %>% select(-id, -Dominio, -Depto)
  
  # Variables num√©ricas
  num_stats <- datos %>%
    select(where(is.numeric)) %>%
    summarise(across(
      everything(),
      list(
        Media = ~mean(.x, na.rm = TRUE),
        DesvEst = ~sd(.x, na.rm = TRUE),
        Min = ~min(.x, na.rm = TRUE),
        Q1 = ~quantile(.x, 0.25, na.rm = TRUE),
        Mediana = ~median(.x, na.rm = TRUE),
        Q3 = ~quantile(.x, 0.75, na.rm = TRUE),
        Max = ~max(.x, na.rm = TRUE),
        NAs = ~sum(is.na(.x))
      ),
      .names = "{.col}.{.fn}"
    ))
  
  # Reorganizar en formato largo
  num_stats_long <- num_stats %>%
    pivot_longer(
      cols = everything(),
      names_to = c("Variable", ".value"),
      names_sep = "\\."
    )
  
  # Variables categ√≥ricas
  cat_vars <- datos %>%
    select(where(~is.character(.x) || is.factor(.x)))
  
  if (ncol(cat_vars) > 0) {
    cat_stats <- data.frame(
      Variable = names(cat_vars),
      Unicos = sapply(cat_vars, function(x) length(unique(x))),
      NAs = sapply(cat_vars, function(x) sum(is.na(x)))
    )
  } else {
    cat_stats <- NULL
  }
  
  # Combinar ambas
  estadisticas <- bind_rows(num_stats_long, cat_stats) %>%
    mutate(Base = nombre_base)
  
  return(estadisticas)
}

# Calcular estad√≠sticas para Train y Test
stats_train <- obtener_estadisticas(train_hogares_final, "Train Hogares Final")
stats_test  <- obtener_estadisticas(test_hogares_final,  "Test Hogares Final")

# Unir ambas bases en una sola tabla
estadisticas_hogares <- bind_rows(stats_train, stats_test)

# Crear tabla √∫nica con subt√≠tulos por base
tabla_estadisticas <- estadisticas_hogares %>%
  gt(groupname_col = "Base") %>%   #Agrupa por base (subt√≠tulos)
  tab_header(
    title = "Estad√≠sticas Descriptivas: Train y Test Hogares Final"
  ) %>%
  cols_label(
    Variable = "Variable",
    Media = "Media",
    DesvEst = "Desv. Est√°ndar",
    Min = "M√≠nimo",
    Q1 = "Q1",
    Mediana = "Mediana",
    Q3 = "Q3",
    Max = "M√°ximo",
    NAs = "N¬∞ NAs",
    Unicos = "N¬∞ √önicos"
  ) %>%
  fmt_number(
    columns = c(Media, DesvEst, Min, Q1, Mediana, Q3, Max),
    decimals = 2
  ) %>%
  tab_style(
    style = cell_text(weight = "bold", color = "white"),
    locations = cells_row_groups()
  ) %>%
  tab_style(
    style = cell_fill(color = "gray40"),
    locations = cells_row_groups()
  ) %>%
  opt_table_font(font = list(google_font("Roboto"))) %>%
  tab_options(
    row_group.as_column = FALSE,    # subt√≠tulo cada base
    table.font.size = px(13),
    table.width = pct(100)
  )

# Exportar tabla a HTML, PDF y PNG
dir.create("Tablas y Graficos", showWarnings = FALSE)

# HTML
gtsave(tabla_estadisticas, "Tablas y Graficos/12.Estadisticas_Descriptivas_Train_y_Test.html")

# PDF
webshot2::webshot(
  "Tablas y Graficos/12.Estadisticas_Descriptivas_Train_y_Test.html",
  "Tablas y Graficos/12.Estadisticas_Descriptivas_Train_y_Test.pdf"
)

# PNG
gtsave(tabla_estadisticas, "Tablas y Graficos/12.Estadisticas_Descriptivas_Train_y_Test.png")

# Mostrar en pantalla
tabla_estadisticas

```



## 3. Modelos y Resultados

```{r}
train_hogares_final
test_hogares_final
```



# ELASTIC NET

```{r}
# Eliminar variables no predictoras
train_modelo_EN <- train_hogares_final %>%
  select(-id, -Dominio, -Depto, -Parentesco_jefe)

test_modelo_EN <- test_hogares_final %>%
  select(-id, -Dominio, -Depto, -Parentesco_jefe)

# Crear matrices
X_train_EN <- model.matrix(Pobre ~ ., data = train_modelo_EN)[, -1]
y_train_EN <- train_modelo_EN$Pobre
X_test <- model.matrix(~ ., data = test_modelo_EN)[, -1]

# Control de entrenamiento
set.seed(2025)

control <- trainControl(
  method = "cv",              # Validaci√≥n cruzada
  number = 5,                 # 5 folds
  classProbs = TRUE,          # Necesario para ROC
  summaryFunction = twoClassSummary,
  savePredictions = TRUE
)

modelo_ElasticNet <- train(
  x = X_train_EN,
  y = y_train_EN,
  method = "glmnet",
  trControl = control,
  metric = "ROC",             # Optimiza AUC
  family = "binomial",
  tuneLength = 10
)

# Resultados
print(modelo_ElasticNet)
plot(modelo_ElasticNet)

```
```{r}
# Confirmar dimensiones
dim(X_train_EN)
length(y_train_EN)
table(y_train_EN)
```
Revisar que el modelo clasifique correctamente "Pobre" como la clase positiva en las predicciones, garantizando que no se invierta la interpretaci√≥n de las probabilidades ni de las m√©tricas de desempe√±o por ejemplo en AUC o sensibilidad.
Nota: En Caret, la clase positiva es siempre el segundo nivel del factor de respuesta.

```{r}
modelo_ElasticNet$trainingData$.outcome %>% levels()
```
```{r}
getTrainPerf(modelo_ElasticNet)

```

```{r}
roc_obj <- roc(response = modelo_ElasticNet$pred$obs,
               predictor = modelo_ElasticNet$pred$Pobre,
               levels = c("NoPobre", "Pobre"))

plot(roc_obj, col = "#2C7BB6", main = "Curva ROC - Elastic Net (Validaci√≥n Cruzada)")
auc(roc_obj)

```

```{r}
pred_class <- ifelse(modelo_ElasticNet$pred$Pobre >= 0.5, "Pobre", "NoPobre") %>%
  factor(levels = c("NoPobre", "Pobre"))

confusionMatrix(pred_class, modelo_ElasticNet$pred$obs, positive = "Pobre")

```
- predecir
```{r}
pred_test <- predict(modelo_ElasticNet, newdata = X_test, type = "prob")

```

```{r}
resultados <- data.frame(
  id = test_hogares_final$id,
  Prob_Pobre = pred_test[, "Pobre"]
)

head(resultados)

```

```{r}
# 1Ô∏è‚É£ Predicciones de probabilidad (para umbral est√°ndar 0.5)
pred_test <- predict(modelo_ElasticNet, newdata = X_test, type = "prob")

# 2Ô∏è‚É£ Convertir probabilidades a clases binarias
pred_test_clase <- ifelse(pred_test[, "Pobre"] >= 0.5, 1, 0)

# 3Ô∏è‚É£ Crear dataframe final con id y clase binaria
resultados2 <- data.frame(
  id = test_hogares_final$id,
  Pobre = pred_test_clase
)

# 4Ô∏è‚É£ Verificar estructura
head(resultados2)
table(resultados2$Pobre)

```




```{r}
# üßπ Eliminar variables no predictoras
# ------------------------------------------------------------
train_modelo_EN <- train_hogares_final %>%
  select(-id, -Dominio, -Depto, -Parentesco_jefe)

test_modelo_EN <- test_hogares_final %>%
  select(-id, -Dominio, -Depto, -Parentesco_jefe)

# ------------------------------------------------------------
# üß© Crear matrices
# ------------------------------------------------------------
train_modelo_EN$Pobre <- factor(train_modelo_EN$Pobre, levels = c("NoPobre", "Pobre"))
X_train_EN <- model.matrix(Pobre ~ ., data = train_modelo_EN)[, -1]
y_train_EN <- train_modelo_EN$Pobre
X_test <- model.matrix(~ ., data = test_modelo_EN)[, -1]

# ------------------------------------------------------------
# ‚öôÔ∏è Control de entrenamiento con m√©tricas extendidas
# ------------------------------------------------------------
fiveStats <- function(...) c(prSummary(...))  # prSummary incluye F1, Recall, Precision, ROC

control <- trainControl(
  method = "cv",               # Validaci√≥n cruzada
  number = 5,                  # 5 folds
  classProbs = TRUE,           # Necesario para ROC y F1
  summaryFunction = fiveStats, # Calcula ROC, F1, Precision y Recall
  savePredictions = TRUE
)

# ------------------------------------------------------------
# üöÄ Entrenamiento del modelo Elastic Net
# ------------------------------------------------------------
set.seed(2025)

modelo_EN_metrics <- train(
  x = X_train_EN,
  y = y_train_EN,
  method = "glmnet",
  trControl = control,
  metric = "ROC",              # Optimiza AUC
  family = "binomial",
  tuneLength = 10
)

# ------------------------------------------------------------
# üìä Resultados del modelo
# ------------------------------------------------------------
print(modelo_EN_metrics)
plot(modelo_EN_metrics)

# Ver los valores √≥ptimos de alpha y lambda
modelo_EN_metrics$bestTune

```
```{r}
# 1) Sanidad b√°sica de columnas (deben coincidir con el entrenamiento)
stopifnot(ncol(X_test) == ncol(X_train_EN))

# 2) Predicci√≥n de CLASE sobre la matriz de prueba correcta
pred_test_lab <- predict(
  modelo_EN_F,
  newdata = X_test,
  type = "raw"            # devuelve "NoPobre" / "Pobre"
)

# Asegurar niveles y orden (negativo/positivo)
pred_test_lab <- factor(pred_test_lab, levels = c("NoPobre", "Pobre"))

# 3) Armar el data.frame con id y etiqueta predicha
predictSample <- data.frame(
  id    = test_hogares_final$id,
  Pobre = pred_test_lab,
  check.names = FALSE
)

# 4) Vistazos r√°pidos
head(predictSample)
table(predictSample$Pobre, useNA = "ifany")

```

```{r}
# ------------------------------------------------------------
# üîπ Crear resultados binarios 0 / 1
# ------------------------------------------------------------
resultados2 <- predictSample %>%
  mutate(
    Pobre = ifelse(Pobre == "Pobre", 1, 0)  # 1 = Pobre, 0 = NoPobre
  ) %>%
  select(id, Pobre)

# ------------------------------------------------------------
# üîé Vista previa y chequeo de balance
# ------------------------------------------------------------
head(resultados2)
table(resultados2$Pobre, useNA = "ifany")

```
```{r}
# ------------------------------------------------------------
# üß© Crear nombre din√°mico del archivo
# ------------------------------------------------------------

# Redondear y limpiar lambda y alpha para usar en el nombre del archivo
lambda_str <- gsub(
  "\\.", "_", 
  as.character(round(modelo_EN_F$bestTune$lambda, 4))  # m√°s precisi√≥n
)

alpha_str <- gsub(
  "\\.", "_", 
  as.character(modelo_EN_F$bestTune$alpha)
)

# Crear el nombre del archivo
name <- paste0(
  "ElasticNet_lambda_", lambda_str,
  "_alpha_", alpha_str,
  ".csv"
)

# ------------------------------------------------------------
# üì§ Exportar resultados binarios (resultados2)
# ------------------------------------------------------------
write.csv(resultados2, name, row.names = FALSE)

# Confirmar nombre generado y ruta
cat("‚úÖ Archivo generado correctamente:", name, "\n")

```
```{r}
# üß© Preparaci√≥n de datos (sin modificar los existentes)
# ------------------------------------------------------------
train_modelo_F1opt <- train_hogares_final %>%
  select(-id, -Dominio, -Depto, -Parentesco_jefe)

test_modelo_F1opt <- test_hogares_final %>%
  select(-id, -Dominio, -Depto, -Parentesco_jefe)

# Variable objetivo como factor binario
train_modelo_F1opt$Pobre <- factor(train_modelo_F1opt$Pobre, levels = c("NoPobre", "Pobre"))

# Crear matrices nuevas
X_train_F1opt <- model.matrix(Pobre ~ ., data = train_modelo_F1opt)[, -1]
y_train_F1opt <- train_modelo_F1opt$Pobre
X_test_F1opt  <- model.matrix(~ ., data = test_modelo_F1opt)[, -1]

# ------------------------------------------------------------
# ‚öôÔ∏è Control de entrenamiento optimizando F1
# ------------------------------------------------------------
fiveStats_F1opt <- function(...) c(prSummary(...))  # F1, Precision, Recall, ROC

ctrl_F1opt <- trainControl(
  method = "cv",
  number = 5,
  classProbs = TRUE,
  summaryFunction = fiveStats_F1opt,
  savePredictions = TRUE
)

# ------------------------------------------------------------
# üöÄ Entrenamiento Elastic Net (Optimiza F1)
# ------------------------------------------------------------
set.seed(2025)

modelo_EN_F1opt <- train(
  x = X_train_F1opt,
  y = y_train_F1opt,
  method = "glmnet",
  trControl = ctrl_F1opt,
  metric = "F",              # Optimiza F1 (m√©trica oficial Kaggle)
  family = "binomial",
  tuneLength = 15
)

# ------------------------------------------------------------
# üìä Revisar resultado
# ------------------------------------------------------------
print(modelo_EN_F1opt)
modelo_EN_F1opt$bestTune

# ------------------------------------------------------------
# üîÆ Predicciones finales sobre test
# ------------------------------------------------------------
pred_test_F1opt <- predict(modelo_EN_F1opt, newdata = X_test_F1opt, type = "raw")

# Crear archivo en formato Kaggle (id + pobre)
submission_F1opt <- data.frame(
  id = test_hogares_final$id,
  pobre = ifelse(pred_test_F1opt == "Pobre", 1, 0)
)

# ------------------------------------------------------------
# üíæ Exportar con nombre autom√°tico
# ------------------------------------------------------------
lambda_str_F1opt <- gsub("\\.", "_", as.character(round(modelo_EN_F1opt$bestTune$lambda, 6)))
alpha_str_F1opt  <- gsub("\\.", "_", as.character(modelo_EN_F1opt$bestTune$alpha))

file_name_F1opt <- paste0("EN_F1_lambda_", lambda_str_F1opt,
                          "_alpha_", alpha_str_F1opt, ".csv")

write.csv(submission_F1opt, file_name_F1opt, row.names = FALSE)

cat("‚úÖ Archivo F1-Optimizado listo para Kaggle:", file_name_F1opt, "\n")

```




```{r}
# üß© Preparaci√≥n de los datos
# ------------------------------------------------------------
# train_modelo_EN ya limpio y con Pobre como factor (NoPobre / Pobre)
X_train_EN <- model.matrix(Pobre ~ ., data = train_modelo_EN)[, -1]
y_train_EN <- train_modelo_EN$Pobre

# ------------------------------------------------------------
# üß† Funci√≥n de evaluaci√≥n
# ------------------------------------------------------------
# prSummary calcula m√©tricas basadas en ROC, F1, Sens, Spec, etc.
# Aqu√≠ puedes a√±adir m√°s si lo deseas
fiveStats <- function(...) {
  c(prSummary(...))
}

# ------------------------------------------------------------
# ‚öôÔ∏è Control de entrenamiento
# ------------------------------------------------------------
ctrl <- trainControl(
  method = "cv",               # Validaci√≥n cruzada
  number = 5,                  # 5 folds
  classProbs = TRUE,           # Necesario para ROC y F1
  summaryFunction = fiveStats, # Usa tus m√©tricas personalizadas
  savePredictions = TRUE
)

# ------------------------------------------------------------
# üöÄ Entrenamiento del modelo Elastic Net
# ------------------------------------------------------------
set.seed(2025)

modelo_EN_F <- train(
  x = X_train_EN,
  y = y_train_EN,
  method = "glmnet",
  trControl = ctrl,
  metric = "F",                # Maximiza F1
  family = "binomial",
  tuneGrid = expand.grid(
    alpha  = seq(0, 1, by = 0.1),             # Mezcla LASSO/Ridge
    lambda = 10^seq(-3, 3, length = 10)       # Penalizaci√≥n
  )
)

# ------------------------------------------------------------
# üìä Resultados
# ------------------------------------------------------------
print(modelo_EN_F)
plot(modelo_EN_F)

```
```{r}
# Predicci√≥n usando la matriz de prueba correcta
pred_test_lab <- predict(modelo_EN_F, newdata = X_test, type = "raw")

# Armar dataframe con id y etiqueta predicha
predictSample <- data.frame(
  id = test_hogares_final$id,
  Pobre = pred_test_lab
)

head(predictSample)
table(predictSample$Pobre)

```


```{r}
# Crear resultados binarios 0/1
resultados2 <- predictSample |>
  mutate(Pobre = ifelse(Pobre == "Pobre", 1, 0)) |>
  select(id, Pobre)

# Vista previa
head(resultados2)
table(resultados2$Pobre)

```
```{r}
# ------------------------------------------------------------
# üß© Crear nombre din√°mico del archivo
# ------------------------------------------------------------

lambda_str <- gsub(
  "\\.", "_", 
  as.character(round(modelo_EN_F$bestTune$lambda, 4))
)

alpha_str <- gsub(
  "\\.", "_", 
  as.character(modelo_EN_F$bestTune$alpha)
)

name <- paste0(
  "ElasticNet_lambda_", lambda_str,
  "_alpha_", alpha_str,
  ".csv"
)

# ------------------------------------------------------------
# üì§ Exportar resultados binarios (resultados2)
# ------------------------------------------------------------
write.csv(resultados2, name, row.names = FALSE)

# Confirmar nombre generado
name


```



### 3.1. Seleccion de modelos y entrenamiento

### 3.2. Hiperparametros

### 3.3. Analisis comparativo

### 3.4. Importancia de las caracteristicas

## 4. Conclusiones

















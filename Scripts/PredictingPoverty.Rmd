---
title: "Problem Set 2 - BDML"
author: "Cristian Mu帽oz - Vivian Cabanzo - Zenneth Olivero - Laura Diaz"
date: "2025-09-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Predicting Poverty

# Predicci贸n de Pobreza en Colombia

## 1. Introducci贸n

## 2. Datos

### 2.1. Limpieza de datos

### - Paquetes y librerias

A continuaci贸n se cargan los paquetes y librerias necesarias para el an谩lisis de informaci贸n.

```{r}
# Instalar y cargar pacman (gestor de paquetes)
if (!require("pacman")) install.packages("pacman")
library(pacman)

# Cargar paquetes necesarios
pacman::p_load(
  knitr,         # Knit en RMarkdown
  tidyverse,     # Incluye dplyr, tidyr, ggplot2, readr, purrr
  readxl,        # Lectura de Excel
  janitor,       # Limpieza r谩pida
  skimr,         # Res煤menes descriptivos
  styler,        # Estilo de c贸digo
  corrplot,      # Matrices de correlaci贸n
  boot,          # Bootstrap
  modelsummary,  # Res煤menes en tablas
  scales,        # Para formatear ejes
  gt,            # Tablas elegantes
  broom,         # Modelos -> data.frames
  survey,        # Encuestas complejas
  rio,           # Importar/exportar
  stargazer,     # Estad铆sticas descriptivas y modelos
  gtsummary,     # Tablas m茅dicas/sociales
  gridExtra,     # Organizar gr谩ficos
  labelled,      # Manejo de etiquetas
  tibble,        # Tablas en consola
  kableExtra,    # Mejorar tablas
  stringi,        # Convertir Car谩cteres
  glmnet,        #Algoritmos de regularizaci贸n
  rpart,         # Arboles de decisi贸n
  rpart.plot,    # Gr谩fico de arboles
  caret,         # Estimaci贸n de modelos predictivos
  Metrics,       # Evaluaci贸n de modelos predictivos
  rpart
)


# Verificar paquetes cargados
pacman::p_loaded()

```

### - Cargar bases de datos

Se proceden a cargar las bases de datos definidas para el an谩lisis.

**Nota:** En primera instancia, se debe garantizar la reproducibilidad del script para cualquier usuario, por lo que se precisa la necesidad de que, tanto el arhivo R Markdown como las bases de datos se almacenen en la misma carpeta o ruta.

```{r}
# Lista de datasets que deben estar en la misma carpeta del .Rmd
Datasets <- c(
  "sample_submission.csv",
  "train_hogares.csv",
  "train_personas.csv",
  "test_hogares.csv",
  "test_personas.csv"
)

# Verificaci贸n
for (Dataset in Datasets) {
  if (file.exists(Dataset)) {
    cat("El dataset", Dataset, "se encuentra en la carpeta para su respectivo cargue a R.\n")
  } else {
    cat("El dataset", Dataset, "NO se encuentra en la carpeta para su respectivo cargue a R.\n")
  }
}

```

Posteriormente, se proceden a cargar los datasets

```{r}
# Cargar datasets en R
sample_submission <- read.csv("sample_submission.csv", stringsAsFactors = FALSE)
train_hogares     <- read.csv("train_hogares.csv", stringsAsFactors = FALSE)
train_personas    <- read.csv("train_personas.csv", stringsAsFactors = FALSE)
test_hogares      <- read.csv("test_hogares.csv", stringsAsFactors = FALSE)
test_personas     <- read.csv("test_personas.csv", stringsAsFactors = FALSE)

# Confirmar cargue mostrando dimensiones de cada dataset
cat("sample_submission:", nrow(sample_submission), "filas y", ncol(sample_submission), "columnas.\n")
cat("train_hogares:", nrow(train_hogares), "filas y", ncol(train_hogares), "columnas.\n")
cat("train_personas:",nrow(train_personas), "filas y", ncol(train_personas), "columnas.\n")
cat("test_hogares:", nrow(test_hogares), "filas y", ncol(test_hogares), "columnas.\n")
cat("test_personas:", nrow(test_personas), "filas y", ncol(test_personas), "columnas.\n")

```

### - Exploraci贸n de bases de datos

Se analizan la bases de datos de entrenamiento y de prueba correspondiente a hogares y a personas, es necesario tener en cuenta que el objetivo es predecir la pobreza a nivel de hogares, por lo que es posible crear variables relevantes para la predicci贸n de pobreza desde el nivel de personas para robustecer los resultados.

Analisis de las bases de datos de entrenamiento y de prueba a nivel de hogares:

```{r}
# Comparar variables
comunes <- intersect(names(train_hogares), names(test_hogares))
solo_train <- setdiff(names(train_hogares), names(test_hogares))
solo_test <- setdiff(names(test_hogares), names(train_hogares))

# Variables exclusivas en test
solo_test_texto <- if (length(solo_test) == 0) "Ninguna variable" else paste(solo_test, collapse = ", ")

# Construir tabla resumen
tabla_resumen <- tibble(
  Categoria = c("En ambos datasets", "Solo en train_hogares", "Solo en test_hogares"),
  Cantidad  = c(length(comunes), length(solo_train), ifelse(length(solo_test) == 0, 0, length(solo_test))),
  Variables = c(
    paste(comunes, collapse = ", "),
    paste(solo_train, collapse = ", "),
    solo_test_texto
  )
)

# Mostrar tabla con gt
tabla_resumen %>%
  gt() %>%
  tab_header(
    title = "Resumen de Variables entre la muestra de entrenamiento y de prueba en Hogares"
  ) %>%
  cols_label(
    Categoria = "Categor铆a",
    Cantidad = "N掳 de Variables",
    Variables = "Variables"
  )

```

La Tabla que precede presenta un resumen comparativo de las variables disponibles en la muestra de entrenamiento y de prueba a nivel de hogares, se observa que ambas bases comparten un total de 16 variables, entre ellas el identificador del hogar (id), atributo fundamental para la creacion de nuevas variables, as铆 como variables socioecon贸micas y demogr谩ficas.

Adicionalmente, se identifican 7 variables exclusivas de la base de entrenamiento (Ingtotug, Ingtotugarr, Ingpcug, Pobre, Indigente, Npobres, Nindigentes), las cuales no est谩n presentes en la base de prueba. Por su parte, el conjunto de prueba no presenta variables exclusivas, lo cual se se帽ala expl铆citamente como "Ninguna variable".

```{r}
# Funci贸n para crear diccionario de un dataset
comparacion_var <- function(df, nombre_df) {
  map_dfr(names(df), function(var) {
    x <- df[[var]]
    tibble(
      Variable = var,
      Tipo = class(x)[1]
    )
  })
}

# Crear diccionarios
comp_train <- comparacion_var(train_hogares, "train")
comp_test  <- comparacion_var(test_hogares, "test")

# Unir en una sola tabla comparativa
comp_combinado <- full_join(
  comp_train %>% rename_with(~paste0(., "_train"), -Variable),
  comp_test  %>% rename_with(~paste0(., "_test"), -Variable),
  by = "Variable"
)

# Reemplazar NA
comp_combinado <- comp_combinado %>%
  mutate(
    Tipo_train = ifelse(is.na(Tipo_train), "No existe variable en el dataset", Tipo_train),
    Tipo_test  = ifelse(is.na(Tipo_test),  "No existe variable en el dataset", Tipo_test)
  )

# Mostrar tabla con gt
comp_combinado %>%
  select(Variable, Tipo_train, Tipo_test) %>%
  gt() %>%
  tab_header(
    title = "Tipo de Variables: Muestra de entrenamiento y de prueba en hogares"
  ) %>%
  tab_spanner(
    label = "Muestra de Entrenamiento",
    columns = c(Tipo_train)
  ) %>%
  tab_spanner(
    label = "Muestra de Prueba",
    columns = c(Tipo_test)
  ) %>%
  cols_label(
    Variable = "Variable",
    Tipo_train = "Tipo",
    Tipo_test = "Tipo"
  )
  
```

Se presenta la comparaci贸n de variables entre las muestras de entrenamiento y de prueba a nivel de hogares, se examinan de manera sistem谩tica aspectos como el tipo de dato para identificar la consistencia en el tipo de variables en ambas bases de datos.

En conjunto, esta tabla complementa el an谩lisis previo y constituye una herramienta fundamental para orientar las decisiones de limpieza, imputaci贸n y selecci贸n de variables en la construcci贸n del modelo de predicci贸n de pobreza.

Por otra parte, es fundamental que las bases de datos de entrenamiento y de prueba utilicen el mismo conjunto de variables explicativas, esto se debe a que el modelo predictivo aprende una funci贸n definida en un espacio de caracter铆sticas espec铆fico; si en la etapa de predicci贸n se presentan variables distintas a las utilizadas en el entrenamiento, los modelos a plantear carecer铆an de la informaci贸n necesaria para generar resultados v谩lidos.

De igual forma, la inclusi贸n de variables adicionales en el entrenamiento que no est谩n presentes en la prueba impide evaluar correctamente la capacidad de predicci贸n de modelos. Es importante resaltar que, la variable objetivo "Pobre" est谩 disponible 煤nicamente en la base de entrenamiento y no en la base de prueba, ya que el prop贸sito principal del analisis es generar predicciones de pobreza a partir de datos conocidos.

Teniendo en cuenta lo anterior, en primera instancia, se define a un hogar como pobre cuando el ingreso del hogar es inferior a la "Linea de Pobreza", como se define a continuaci贸n:

\$\$\
Pobre = I \cdot (Ingreso \< \text{L铆nea de Pobreza})\
\$\$

Se asigna el valor de la variable "Pobre" de acuerdo con el resultado de la funci贸n que precede,

$$
\
Donde \ I:
\\
I(\text{Funci贸n indicadora}) =
\begin{cases} 
0, & \text{Ingreso superior a la linea de pobreza = No Pobre} \\
1, & \text{Ingreso inferior a la linea de pobreza = Pobre}
\end{cases}
\
$$ De acuerdo con la definici贸n anterior, se seleccionan en la base de datos de entrenamiento aquellas variables que se encuentran en la base de prueba y se mantiene la variable objetivo "Pobre", con la cual se entrenar谩n los diferentes modelos para realizar predicciones en la base de prueba.

```{r}
# Variables en com煤n entre train y test
vars_comunes <- intersect(names(train_hogares), names(test_hogares))

# Mantener las variables comunes y "Pobre"
vars_finales <- c(vars_comunes, "Pobre")

# Filtro de train_hogares
train_hogares2 <- train_hogares %>%
  select(all_of(vars_finales))

# Verificar
cat("N煤mero de variables en train original:", ncol(train_hogares), "\n")
cat("N煤mero de variables en train depurado:", ncol(train_hogares2), "\n")

```

Al realizar la depuraci贸n inicial se exploran las variables restantes, con el objetivo de comprenderlas a fondo y definir su relevancia dentro de la prediccion de pobreza de los hogares.

```{r}
# Crear tabla manual de variables (diccionario)
tabla_vars <- tibble::tibble(
  Variable = c(
    "id", "Clase", "Dominio", "P5000", "P5010", "P5090", "P5100",
    "P5130", "P5140", "Nper", "Npersug", "Li", "Lp",
    "Fex_c", "Depto", "Fex_dpto", "Pobre"
  ),
  Descripcion = c(
    "Llave de hogar",
    "1. Cabecera; 2. Resto (centros poblados y 谩rea rural dispersa)",
    "reas metropolitanas, cabeceras y resto",
    "Total habitaciones",
    "Dormitorios",
    "Tipo de vivienda: a.Propia, totalmente pagada 
    b. Propia, la est谩n pagando
    c. En arriendo o subarriendo
    d. En usufructo e. Posesi贸n sin titulo (ocupante)
    f. Otra",
    "Cuota de amortizaci贸n",
    "Valor estimado de arriendo",
    "Valor de arriendo",
    "N煤mero de personas en el hogar",
    "N煤mero de personas en la unidad de gasto",
    "L铆nea de indigencia",
    "L铆nea de pobreza",
    "Factor de expansi贸n",
    "Departamento",
    "Factor de expansi贸n departamental",
    "1 = Pobre ; 0 = No pobre"
  )
)

# Mostrar diccionario con gt
tabla_vars %>%
  gt() %>%
  tab_header(
    title = "Diccionario de Variables: train_hogares"
  ) %>%
  cols_label(
    Variable = "Variable",
    Descripcion = "Descripci贸n"
  )

# Renombrar variables en el dataset seg煤n el diccionario
train_hogares2 <- train_hogares2 %>%
  rename(
    Total_habitaciones = P5000,
    Dormitorios = P5010,
    Tipo_vivienda = P5090,
    Cuota_amortizacion = P5100,
    Valor_estimado_arriendo = P5130,
    Valor_arriendo = P5140,
  )
```

Es necesario resaltar que, si bien las variables que contiene ingresos en la base de entrenamiento fueron eliminadas, no presenta ninguna implicacion ya que, dentro de la base existe la variable "Pobre", la cual por definici贸n representa que los ingresos de determinados hogares son inferiores a la linea de pobreza.

A contiuaci贸n, se presentan las variables contenidas en el dataset de entrenamiento de Hogares y se exploran los valores faltantes.

```{r}
# Renombrar variables en test_hogares igual que en train_hogares
test_hogares2 <- test_hogares %>%
  rename(
    Total_habitaciones = P5000,
    Dormitorios = P5010,
    Tipo_vivienda = P5090,
    Cuota_amortizacion = P5100,
    Valor_estimado_arriendo = P5130,
    Valor_arriendo = P5140,
  )

# Calcular % de faltantes en TRAIN
faltantes_train <- train_hogares2 %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Porcentaje_NA") %>%
  mutate(Base = "Entrenamiento")

# Calcular % de faltantes en TEST
faltantes_test <- test_hogares2 %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Porcentaje_NA") %>%
  mutate(Base = "Prueba")

# Unir ambas bases
faltantes_comp <- bind_rows(faltantes_train, faltantes_test)

# Reordenar factores id, Clase, Dominio y Depto 
orden_vars <- c(setdiff(unique(faltantes_comp$Variable), 
                        c("Depto", "Dominio","Clase", "id")),
                "Depto", "Dominio","Clase", "id")

faltantes_comp <- faltantes_comp %>%
  mutate(Variable = factor(Variable, levels = orden_vars))

# Gr谩fico comparativo
grafico_faltantes <- ggplot(faltantes_comp, aes(x = Variable, 
                                                y = Porcentaje_NA, fill = Base)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = paste0(round(Porcentaje_NA, 2), "%")), 
            position = position_dodge(width = 0.9), 
            vjust = -0.3, size = 3) +
  coord_flip() +
  labs(title = "Comparaci贸n de % de valores faltantes por variable\nTrain vs Test (hogares)",
       x = "Variable", y = "% de valores faltantes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(values = c("Entrenamiento" = "lightyellow4",
                               "Prueba"        = "#FFFF00")) 

# Mostrar el gr谩fico en consola
print(grafico_faltantes)

# Exportar a PDF
ggsave("Faltantes_Train.pdf", grafico_faltantes, width = 10, height = 6)

```

La gr谩fica que precede, ofrece una visi贸n m谩s precisa de la calidad de los datos, resaltando aquellas variables con un porcentaje considerable de valores faltantes que podr铆an comprometer el desempe帽o de los modelos predictivos. Se evidencia un alto porcentaje de datos faltantes en las mismas variables para las dos bases, a saber, el valor estimado en caso de pagar arriendo en una vivienda, la cuota de amortizaci贸n por cr茅dito hipotecario y el valor actual del arriendo, por lo que dichas variables podrian omitirse en ambas bases.

Adicionalmente, las dem谩s variables no presentan datos faltantes, sin embargo, "id", "Clase", "Dominio" y "Depto" son atributos de identificacion por lo que no se usar谩n como posibles predictoras aunque se mantengan en la base.

Por su parte, los factores de expansi贸n no representan caracteristicas intrinsecas que contribuyan a la predicci贸n del estado de pobreza de un hogar en Colombia, estas corresponden a atributos para el analisis poblacional por lo que no se utilizar谩n para predecir.

En cuanto a la linea de pobreza y a la linea de indigencia, estas variables no son necesarias puesto que ya existe la variable que clasifica a los hogares pobres de aquellos que no lo son.

Por lo anterior, dentro de lo explorado se mantendr谩n las variables "Tipo de vivienda" y "Numero de personas en el hogar", en este orden de ideas se debe proceder a explorar las bases de entrenamiento y de prueba en el nivel de Personas para identificar posibles variables que contribuyan a la prediccion adecuada del estado de pobreza.

```{r}
# Comparar variables entre train_personas y test_personas
comunes2 <- intersect(names(train_personas), names(test_personas))
solo_train_p <- setdiff(names(train_personas), names(test_personas))
solo_test_p <- setdiff(names(test_personas), names(train_personas))

# Variables exclusivas en test_personas
solo_test_texto_p <- if (length(solo_test_p) == 0) "Ninguna variable" else paste(solo_test_p, collapse = ", ")

# Construir tabla resumen
tabla_resumen_personas <- tibble(
  Categoria = c("En ambos datasets", "Solo en train_personas", "Solo en test_personas"),
  Cantidad  = c(length(comunes2), length(solo_train_p), ifelse(length(solo_test_p) == 0, 0, length(solo_test_p))),
  Variables = c(
    paste(comunes2, collapse = ", "),
    paste(solo_train_p, collapse = ", "),
    solo_test_texto_p
  )
)

# Mostrar tabla con gt
tabla_resumen_personas %>%
  gt() %>%
  tab_header(
    title = "Resumen de Variables entre la muestra de entrenamiento y de prueba en Personas"
  ) %>%
  cols_label(
    Categoria = "Categor铆a",
    Cantidad = "N掳 de Variables",
    Variables = "Variables"
  )


```

Del analisis de las variables en comun, se identifican 63 que se encuentran en la base de entrenamiento y de prueba, se proceder谩 a realizar un analisis de valores faltantes para seleccionar de forma adecuada variables que permitan predecir el estado de pobreza.

```{r}
# Identificar variables comunes
vars_comunes_p <- intersect(names(train_personas), names(test_personas))

# Calcular % de faltantes en TRAIN_PERSONAS
faltantes_train_p <- train_personas %>%
  select(all_of(vars_comunes_p)) %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Porcentaje_NA") %>%
  mutate(Base = "Train Personas")

# Calcular % de faltantes en TEST_PERSONAS
faltantes_test_p <- test_personas %>%
  select(all_of(vars_comunes_p)) %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Porcentaje_NA") %>%
  mutate(Base = "Test Personas")

# Unir ambas bases
faltantes_comp_personas <- bind_rows(faltantes_train_p, faltantes_test_p)

# Clasificar en rangos de % de faltantes
faltantes_comp_personas <- faltantes_comp_personas %>%
  mutate(Categoria = case_when(
    Porcentaje_NA == 0 ~ "0%",
    Porcentaje_NA > 0 & Porcentaje_NA <= 30 ~ "1% - 30%",
    Porcentaje_NA > 30 & Porcentaje_NA <= 50 ~ "31% - 50%",
    Porcentaje_NA > 50 & Porcentaje_NA < 100 ~ "51% - 99%",
    Porcentaje_NA == 100 ~ "100%"
  ))

# Resumir n煤mero de variables por categor铆a
resumen_faltantes <- faltantes_comp_personas %>%
  group_by(Base, Categoria) %>%
  summarise(N_variables = n(), .groups = "drop")

# Gr谩fico resumido
grafico_resumen <- ggplot(resumen_faltantes, aes(x = Categoria, y = N_variables, fill = Base)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = N_variables), 
            position = position_dodge(width = 0.9), 
            vjust = -0.3, size = 4) +
  labs(title = "Distribuci贸n de variables comunes seg煤n % de faltantes\nMuestra de entramiento y prueba de Personas",
       x = "Categor铆a de % de faltantes", y = "N煤mero de variables") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(values = c("Train Personas" = "lightyellow4",
                               "Test Personas"  = "#FFFF00"))

# Mostrar en consola
print(grafico_resumen)

# Exportar a PDF
ggsave("Resumen_Faltantes_Train_vs_Test_Personas.pdf", grafico_resumen, width = 8, height = 6)


```

De acuerdo con la grafica, existen 45 variables con mas del 50% de valores faltantes en las dos bases a nivel de personas, por lo que no es procedente tenerlas en cuenta para el entrenamiento. Por su parte, 18 variables se revisar谩n.

```{r}
# Calcular % de faltantes en TRAIN_PERSONAS
faltantes_train_p <- train_personas %>%
  select(all_of(vars_comunes_p)) %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), 
               names_to = "Variable", 
               values_to = "Pct_Faltantes_Train")

# Calcular % de faltantes en TEST_PERSONAS
faltantes_test_p <- test_personas %>%
  select(all_of(vars_comunes_p)) %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), 
               names_to = "Variable", 
               values_to = "Pct_Faltantes_Test")

# Unir ambos resultados
faltantes_comp_personas <- left_join(faltantes_train_p, faltantes_test_p, by = "Variable")

# Clasificar por categor铆as de % de faltantes
faltantes_comp_personas <- faltantes_comp_personas %>%
  mutate(Categoria = case_when(
    Pct_Faltantes_Train == 0 & Pct_Faltantes_Test == 0 ~ "0% faltantes",
    (Pct_Faltantes_Train >= 1 & Pct_Faltantes_Train <= 30) |
      (Pct_Faltantes_Test >= 1 & Pct_Faltantes_Test <= 30) ~ "1% - 30%",
    TRUE ~ "M谩s del 30%"
  ))

# Filtrar de 0% a 30% (no necesitamos mostrar Categor铆a en la tabla final)
faltantes_interes <- faltantes_comp_personas %>%
  filter(Categoria %in% c("0% faltantes", "1% - 30%")) %>%
  select(Variable, Pct_Faltantes_Train, Pct_Faltantes_Test)

# Crear tabla con gt
tabla_faltantes <- faltantes_interes %>%
  gt() %>%
  tab_header(
    title = "Variables con 0%-30% de valores faltantes\nTrain Personas vs Test Personas"
  ) %>%
  cols_label(
    Variable = "Variable",
    Pct_Faltantes_Train = "% Faltantes Train",
    Pct_Faltantes_Test = "% Faltantes Test"
  ) %>%
  fmt_number(
    columns = c(Pct_Faltantes_Train, Pct_Faltantes_Test),
    decimals = 2
  )

# Mostrar tabla en consola
tabla_faltantes

```

```{r}
# Renombrar variables en test_personas igual que en train_personas
test_personas2 <- test_personas %>%
  rename(
    Parentesco_jefe = P6050,
    Edad = P6040,
    Sexo = P6020,
    Nivel_educativo = P6210,
    Actividad_Ocup = P6240
  )

train_personas2 <- train_personas %>%
  rename(
    Parentesco_jefe = P6050,
    Edad = P6040,
    Sexo = P6020,
    Nivel_educativo = P6210,
    Actividad_Ocup = P6240
  )

# Variables en com煤n ya con nombres descriptivos
vars_comunes_p <- intersect(names(train_personas2), names(test_personas2))

# Calcular % de faltantes en TRAIN_PERSONAS
faltantes_train_p <- train_personas2 %>%
  select(all_of(vars_comunes_p)) %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), 
               names_to = "Variable", 
               values_to = "Porcentaje_NA") %>%
  mutate(Base = "Train Personas")

# Calcular % de faltantes en TEST_PERSONAS
faltantes_test_p <- test_personas2 %>%
  select(all_of(vars_comunes_p)) %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), 
               names_to = "Variable", 
               values_to = "Porcentaje_NA") %>%
  mutate(Base = "Test Personas")

# Unir ambas bases
faltantes_comp_p <- bind_rows(faltantes_train_p, faltantes_test_p)

# Filtrar solo variables con % de faltantes entre 0% y 30%
faltantes_comp_p <- faltantes_comp_p %>%
  filter(Porcentaje_NA >= 0 & Porcentaje_NA <= 30)

# Gr谩fico comparativo
grafico_faltantes_p <- ggplot(faltantes_comp_p, aes(x = reorder(Variable, -Porcentaje_NA), 
                                                    y = Porcentaje_NA, fill = Base)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = paste0(round(Porcentaje_NA, 2), "%")), 
            position = position_dodge(width = 0.9), 
            vjust = -0.3, size = 3) +
  coord_flip() +
  labs(title = "Comparaci贸n de % de valores faltantes (0%-30%)\nTrain Personas vs Test Personas",
       x = "Variable", y = "% de valores faltantes") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(values = c("Train Personas" = "lightyellow4",
                               "Test Personas"  = "#FFFF00"))

# Mostrar gr谩fico en consola
print(grafico_faltantes_p)

# Exportar a PDF
ggsave("Faltantes_Train_vs_Test_Personas.pdf", grafico_faltantes_p, width = 10, height = 6)

```

### - Base de Entrenamiento Final

La base de datos de entrenamiento definitiva para las predicciones de pobreza a nivel de hogares es: train_hogares_final

```{r}
# Seleccionar variables de hogares
train_hogares_sel <- train_hogares2 %>%
  select(id, Clase, Dominio, Tipo_vivienda, Nper, Depto, Pobre)

# Filtrar jefe de hogar en personas (soporta num茅rico, factor o car谩cter)
jefes_hogar <- train_personas2 %>%
  filter(as.character(Parentesco_jefe) == "1") %>%  # se asegura de tomar "1" en cualquier tipo
  select(id, Parentesco_jefe, Sexo, Edad, Nivel_educativo, Actividad_Ocup)

# Merge hogares + jefe de hogar
train_hogares_final <- train_hogares_sel %>%
  left_join(jefes_hogar, by = "id")

# Revisar resultado
glimpse(train_hogares_final)

```

revision de datos faltantes;

```{r}
faltantes_train_final <- train_hogares_final %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), 
               names_to = "Variable", 
               values_to = "N_faltantes") %>%
  mutate(Pct_faltantes = round((N_faltantes / nrow(train_hogares_final)) * 100, 2))

# Mostrar en tabla bonita
faltantes_train_final %>%
  gt() %>%
  tab_header(title = "Valores faltantes en train_hogares_final") %>%
  cols_label(
    Variable = "Variable",
    N_faltantes = "N掳 Faltantes",
    Pct_faltantes = "% Faltantes"
  )
```

### - Base de Prueba Final

La base de datos de prueba definitiva para las predicciones de pobreza a nivel de gares es: test_hogares_final

```{r}

# Seleccionar variables de hogares
test_hogares_sel <- test_hogares2 %>%
  select(id, Clase, Dominio, Tipo_vivienda, Nper, Depto)

# Filtrar jefe de hogar en personas (soporta num茅rico, factor o car谩cter)
jefes_hogar1 <- test_personas2 %>%
  filter(as.character(Parentesco_jefe) == "1") %>%  # se asegura de tomar "1" en cualquier tipo
  select(id, Parentesco_jefe, Sexo, Edad, Nivel_educativo, Actividad_Ocup)

# Merge hogares + jefe de hogar
test_hogares_final <- test_hogares_sel %>%
  left_join(jefes_hogar1, by = "id")

# Revisar resultado
glimpse(test_hogares_final)

```

Revision de datos faltantes:

```{r}
faltantes_test_final <- test_hogares_final %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), 
               names_to = "Variable", 
               values_to = "N_faltantes") %>%
  mutate(Pct_faltantes = round((N_faltantes / nrow(test_hogares_final)) * 100, 2))


# Mostrar en tabla bonita
faltantes_test_final %>%
  gt() %>%
  tab_header(title = "Valores faltantes en test_hogares_final") %>%
  cols_label(
    Variable = "Variable",
    N_faltantes = "N掳 Faltantes",
    Pct_faltantes = "% Faltantes"
  )

```

Se evidencia un valor faltante en la variable Actividad_Ocup para cada base final, por lo que se procede a imputar con la moda:

```{r}
# Funcion Imputar NAs con la moda
imputar_moda <- function(df, variable) {
  moda <- df %>%
    filter(!is.na(.data[[variable]])) %>%
    count(.data[[variable]]) %>%
    arrange(desc(n)) %>%
    slice(1) %>%
    pull(1)
  
  df %>%
    mutate("{variable}" := ifelse(is.na(.data[[variable]]), moda, .data[[variable]]))
}

# Imputar en train_hogares_final
train_hogares_final <- imputar_moda(train_hogares_final, "Actividad_Ocup")

# Imputar en test_hogares_final
test_hogares_final <- imputar_moda(test_hogares_final, "Actividad_Ocup")

# Chequear que no queden NAs
cat("Faltantes en train_hogares_final:", sum(is.na(train_hogares_final$Actividad_Ocup)), "\n")
cat("Faltantes en test_hogares_final:", sum(is.na(test_hogares_final$Actividad_Ocup)), "\n")
```

### 2.2. Estad铆sticas descriptivas

Tabla de estadisticas descriptivas de las bases de datos a nivel de hogares.

```{r}
# Crear tabla de diccionario solo con variables finales
tabla_vars_final <- tibble::tibble(
  Variable = c(
    "id", "Clase", "Dominio", "Tipo_vivienda", 
    "Nper", "Depto", "Pobre", 
    "Parentesco_jefe", "Sexo", "Edad", 
    "Nivel_educativo", "Actividad_Ocup"
  ),
  Descripcion = c(
    "Llave 煤nica del hogar",
    "Clase de centro poblado: 1. Cabecera; 2. Resto (centros poblados y rural dispersa)",
    "Dominio geogr谩fico: 谩reas metropolitanas, cabeceras y resto",
    "Tipo de vivienda: a. Propia pagada, b. Propia pagando, c. Arriendo/subarriendo, d. Usufructo, e. Ocupante sin t铆tulo, f. Otra",
    "N煤mero de personas en el hogar",
    "Departamento de residencia",
    "1 = Pobre ; 0 = No pobre (solo en entrenamiento)",
    "Parentesco con el jefe de hogar (1 = jefe, otros = distintos roles)",
    "Sexo del jefe de hogar (1 = Hombre, 2 = Mujer)",
    "Edad del jefe de hogar (en a帽os)",
    "Nivel educativo alcanzado por el jefe de hogar: a. Ninguno, b.Preescolar, c. B谩sica primaria, d.B谩sica secundaria, e. Media. f. Superior o universitaria, g. No sabe,no informa",
    "Condici贸n de actividad u ocupaci贸n del jefe de hogar:a.Trabajando, b. Buscando trabajo, c.Estudiando, d. Oficios del hogar, e.Incapacitado permanente para trabajar, f.Otra actividad"
  )
)

# Mostrar con gt
tabla_vars_final %>%
  gt() %>%
  tab_header(
    title = "Diccionario de Variables: Bases Finales (Hogares)"
  ) %>%
  cols_label(
    Variable = "Variable",
    Descripcion = "Descripci贸n"
  )

```

## 3. Modelos y Resultados

```{r}
train_hogares_final
test_hogares_final
```

### 3.1. Seleccion de modelos y entrenamiento

En esta secci贸n se realizar谩 la evaluaci贸n de los modelos de predicci贸n.

####  Modelo Carts

El modelo CART utiliza un 谩rbol de decisi贸n binario para predecir la condici贸n de pobreza de los hogares.
Divide los datos en grupos cada vez m谩s homog茅neos seg煤n variables como tipo de vivienda, nivel educativo, n煤mero de personas y ocupaci贸n del jefe del hogar.

Cada divisi贸n se elige para maximizar la pureza de las clases (pobres o no pobres) y el 谩rbol se poda para evitar sobreajuste.


```{r}

# Verificar variable dependiente
table(train_hogares_final$Pobre)

# Convertir a factor (clasificaci贸n)
train_hogares_final$Pobre <- factor(train_hogares_final$Pobre,
                                    levels = c(0, 1),
                                    labels = c("No Pobre", "Pobre"))

# Asegurar formato de variables categ贸ricas
train_hogares_final <- train_hogares_final %>%
  mutate(
    across(c(Clase, Dominio, Tipo_vivienda, Parentesco_jefe, Sexo,
             Nivel_educativo, Actividad_Ocup), as.factor)
  )

# Entrenar con control ajustado
modelo_cart <- rpart(
  Pobre ~ Clase + Dominio + Tipo_vivienda + Nper + Depto + 
    Parentesco_jefe + Sexo + Edad + Nivel_educativo + Actividad_Ocup,
  data = train_hogares_final,
  method = "class"
)

prp(modelo_cart, 
    under = TRUE, 
    branch.lty = 2, 
    yesno = 1, 
    faclen = 0, 
    varlen = 15,
    box.palette = "-RdYlGn")
```
```{r}
pobre        <- ifelse(train_hogares_final$Pobre=="Yes",1,0) 
pred_prob    <- predict(modelo_cart, newdata = test_hogares_final, type = "prob") 
aucval_pobre <- Metrics::auc(actual = pobre,predicted = pred_prob[,2]) #calcular el AUC
aucval_pobre 
```


```{r}

# --- 7锔 Visualizar el 谩rbol ---
rpart.plot(modelo_cart,
           type = 3,           # nodos con texto y ramas claras
           extra = 101,        # muestra clase y probabilidad
           fallen.leaves = TRUE,
           main = "rbol de Decisi贸n - Predicci贸n de Pobreza")

# --- 8锔 Evaluar desempe帽o ---
# Predicciones sobre el conjunto de prueba
pred_cart <- predict(modelo_cart, newdata = test, type = "class")

# Matriz de confusi贸n
confusionMatrix(pred_cart, test$Pobre, positive = "Pobre")

# --- 9锔 Importancia de variables ---
modelo_cart$variable.importance

# ---  (Opcional) Validaci贸n cruzada ---
ctrl <- trainControl(method = "cv", number = 10)
modelo_cv <- train(
  Pobre ~ Clase + Dominio + Tipo_vivienda + Nper + Depto +
    Parentesco_jefe + Sexo + Edad + Nivel_educativo + Actividad_Ocup,
  data = train,
  method = "rpart",
  trControl = ctrl,
  tuneLength = 10
) 


# Mostrar resultados de validaci贸n cruzada
print(modelo_cv)
plot(modelo_cv)
```

### 3.2. Hiperparametros

### 3.3. Analisis comparativo

### 3.4. Importancia de las caracteristicas

## 4. Conclusiones
